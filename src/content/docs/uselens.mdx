---
title: useLens
description: Type-safe functional lenses for React Hook Form
sidebar: apiLinks
---

## \</> `useLens`

React Hook Form Lenses is a powerful TypeScript-first library that brings the elegance of functional lenses to React Hook Form. By providing type-safe manipulation of nested form state, it enables developers to precisely control and transform complex form data with ease.

### Installation

```bash copy
npm install @hookform/lenses
```

### Features

- **Type-Safe Form State**: Focus on specific parts of your form state with full TypeScript support and precise type inference
- **Functional Lenses**: Build complex form state transformations through composable lens operations
- **Deep Structure Support**: Handle deeply nested structures and arrays elegantly with specialized array operations
- **Seamless Integration**: Work smoothly with React Hook Form's Control API and existing functionality
- **Optimized Performance**: Each lens is cached and reused for optimal performance
- **Array Handling**: Specialized support for array fields with type-safe mapping
- **Composable API**: Build complex form state transformations through lens composition

---

## API Reference

| Method | Description | Returns |
|--------|-------------|---------|
| [`focus`](#focus) | Focuses on a specific field path | `Lens<PathValue>` |
| [`reflect`](#reflect) | Transforms lens structure | `Lens<NewStructure>` |
| [`map`](#map) | Maps over array with useFieldArray fields | `R[]` |
| [`interop`](#interop) | Provides React Hook Form integration | `{ control, name }` |

---


## Basic Usage

```tsx copy sandbox="https://codesandbox.io/p/sandbox/keen-herschel-y5h2ft"
import { useForm } from 'react-hook-form';
import { Lens, useLens } from '@hookform/lenses';
import { useFieldArray } from '@hookform/lenses/rhf';

function FormComponent() {
  const { handleSubmit, control } = useForm<{
    firstName: string;
    lastName: string;
    children: {
      name: string;
      surname: string;
    }[];
  }>({});

  const lens = useLens({ control });

  return (
    <form onSubmit={handleSubmit(console.log)}>
      <PersonForm
        lens={lens.reflect(({ firstName, lastName }) => ({
          name: firstName,
          surname: lastName,
        }))}
      />
      <ChildForm lens={lens.focus('children')} />
      <input type="submit" />
    </form>
  );
}

function ChildForm({ lens }: { lens: Lens<{ name: string; surname: string }[]> }) {
  const { fields, append } = useFieldArray(lens.interop());

  return (
    <>
      <button type="button" onClick={() => append({ name: '', surname: '' })}>
        Add child
      </button>
      {lens.map(fields, (value, l) => (
        <PersonForm key={value.id} lens={l} />
      ))}
    </>
  );
}

// PersonForm is used twice with different sources
function PersonForm({ lens }: { lens: Lens<{ name: string; surname: string }> }) {
  return (
    <div>
      <StringInput lens={lens.focus('name')} />
      <StringInput lens={lens.focus('surname')} />
    </div>
  );
}

function StringInput({ lens }: { lens: Lens<string> }) {
  return <input {...lens.interop((ctrl, name) => ctrl.register(name))} />;
}
```

# Motivation

Working with complex, deeply nested forms in React can quickly become challenging. Traditional approaches often lead to:

#### Problems with String-Based Field Names

```tsx
// ❌ Fragile string-based approach
const { register } = useForm<ComplexFormData>();

// No type safety, prone to typos
<input {...register('user.profile.personalInfo.firstName')} />
<input {...register('user.profile.personalInfo.lastName')} />
<input {...register('user.profile.contactInfo.email')} />

// Refactoring nightmare when data structure changes
// Hard to catch errors at compile time
```

#### Component Reusability Challenges

```tsx
// ❌ Hard to create reusable components
function PersonForm({ basePath }: { basePath: string }) {
  const { register } = useForm();

  return (
    <div>
      {/* String concatenation prone to errors */}
      <input {...register(`${basePath}.firstName`)} />
      <input {...register(`${basePath}.lastName`)} />
      <input {...register(`${basePath}.email`)} />
    </div>
  );
}

// Usage becomes unwieldy
<PersonForm basePath="user.profile.owner" />
<PersonForm basePath="user.profile.emergency_contact" />
```

#### Prop Drilling and Type Safety difficulties

```tsx
// ❌ Prop drilling control and register through component tree
function ComplexForm() {
  const { control, register } = useForm<FormData>();

  return (
    <UserSection control={control} register={register} />
  );
}

function UserSection({ control, register }: Props) {
  return (
    <ProfileSection control={control} register={register} />
  );
}

function ProfileSection({ control, register }: Props) {
  // Finally use the props deep in the tree
  return <input {...register('user.profile.name')} />;
}
```


# Props

#### `control`: <TypeText>Control\<TFieldValues></TypeText>

The control object from React Hook Form's `useForm` hook.

```tsx copy
const { control } = useForm<MyFormData>();
const lens = useLens({ control });
```

You can also pass dependencies to clear lenses cache and re-create all of them:

```tsx copy
const lens = useLens({ control }, [dependencies]);
```

---

# Core Operations

### focus {#focus}

Creates a new lens focused on a specific path. This is the primary method for drilling down into your form data structure.

```tsx copy
// Type-safe path focusing
const profileLens = lens.focus('profile');
const emailLens = lens.focus('profile.email');
const arrayItemLens = lens.focus('users.0.name');
```

**Array focusing:**

```tsx copy
function ContactsList({ lens }: { lens: Lens<Contact[]> }) {
  // Focus on specific array index
  const firstContact = lens.focus('0');
  const secondContactName = lens.focus('1.name');

  return (
    <div>
      <ContactForm lens={firstContact} />
      <input {...secondContactName.interop((ctrl, name) => ctrl.register(name))} />
    </div>
  );
}
```

<Admonition type="important" title="TypeScript Support">

The `focus` method provides full TypeScript support with autocompletion and type checking:

- Autocomplete available field paths
- Type errors for non-existent paths
- Inferred return types based on focused field

</Admonition>

---

### reflect {#reflect}

Transforms the lens structure with type inference. This is useful when you want to create a new lens from an existing one with a different shape to pass to shared components.

#### Object Reflection

```tsx copy
const contactLens = lens.reflect(({ profile }) => ({
  name: profile.focus('firstName'),
  phoneNumber: profile.focus('phone'),
}));

<SharedComponent lens={contactLens} />;

function SharedComponent({ lens }: { lens: Lens<{ name: string; phoneNumber: string }> }) {
  return (
    <div>
      <input {...lens.focus('name').interop((ctrl, name) => ctrl.register(name))} />
      <input {...lens.focus('phoneNumber').interop((ctrl, name) => ctrl.register(name))} />
    </div>
  );
}
```

**Alternative syntax using the lens parameter:**

```tsx copy
const contactLens = lens.reflect((_, l) => ({
  name: l.focus('profile.firstName'),
  phoneNumber: l.focus('profile.phone'),
}));
```

#### Array Reflection

```tsx copy
function ArrayComponent({ lens }: { lens: Lens<{ value: string }[]> }) {
  return <AnotherComponent lens={lens.reflect((_, l) => [{ data: l.focus('value') }])} />;
}

function AnotherComponent({ lens }: { lens: Lens<{ data: string }[]> }) {
  // Handle restructured array
}
```

<Admonition type="note">

For array reflection, you must pass an array with a single item representing the template structure.

</Admonition>

#### Merging Lenses

```tsx copy
function Component({
  lensA,
  lensB
}: {
  lensA: Lens<{ firstName: string }>;
  lensB: Lens<{ lastName: string }>
}) {
  const combined = lensA.reflect((_, l) => ({
    firstName: l.focus('firstName'),
    lastName: lensB.focus('lastName'),
  }));

  return <PersonForm lens={combined} />;
}
```

#### Spread Operator Support

```tsx copy
function Component({ lens }: { lens: Lens<{ firstName: string; lastName: string; age: number }> }) {
  return (
    <PersonForm
      lens={lens.reflect(({ firstName, lastName, ...rest }) => ({
        ...rest,
        name: firstName,
        surname: lastName,
      }))}
    />
  );
}
```

---

### map {#map}

Maps over array fields with `useFieldArray` integration. This method requires the `fields` property from `useFieldArray`.

```tsx copy
import { useFieldArray } from '@hookform/lenses/rhf';

function ContactsList({ lens }: { lens: Lens<Contact[]> }) {
  const { fields, append, remove } = useFieldArray(lens.interop());

  return (
    <div>
      <button onClick={() => append({ name: '', email: '' })}>
        Add Contact
      </button>

      {lens.map(fields, (value, l, index) => (
        <div key={value.id}>
          <button onClick={() => remove(index)}>Remove</button>
          <ContactForm lens={l} />
        </div>
      ))}
    </div>
  );
}

function ContactForm({ lens }: { lens: Lens<{ name: string; email: string }> }) {
  return (
    <div>
      <input {...lens.focus('name').interop((ctrl, name) => ctrl.register(name))} />
      <input {...lens.focus('email').interop((ctrl, name) => ctrl.register(name))} />
    </div>
  );
}
```

**Map callback parameters:**

| Parameter | Type | Description |
|-----------|------|-------------|
| `value` | `T` | The current field value with `id` |
| `lens` | `Lens<T>` | Lens focused on the current array item |
| `index` | `number` | Current array index |
| `array` | `T[]` | The complete array |
| `originLens` | `Lens<T[]>` | The original array lens |

---

### interop {#interop}

The `interop` method provides integration with React Hook Form by exposing the underlying `control` and `name` properties.

#### Basic Usage

```tsx copy
const { control, name } = lens.interop();
return <input {...control.register(name)} />;
```

#### Callback Style

```tsx copy
return (
  <input {...lens.interop((ctrl, name) => ctrl.register(name))} />
);
```

#### With useController

```tsx copy
import { useController } from 'react-hook-form';

function ControlledInput({ lens }: { lens: Lens<string> }) {
  const { field, fieldState } = useController(lens.interop());

  return (
    <div>
      <input {...field} />
      {fieldState.error && <p>{fieldState.error.message}</p>}
    </div>
  );
}
```

---

### useFieldArray {#usefieldarray}

Import the enhanced `useFieldArray` from `@hookform/lenses/rhf` for seamless array handling with lenses.

```tsx copy
import { useFieldArray } from '@hookform/lenses/rhf';

function DynamicForm({ lens }: { lens: Lens<{ items: { name: string; value: number }[] }> }) {
  const itemsLens = lens.focus('items');
  const { fields, append, remove, move } = useFieldArray(itemsLens.interop());

  return (
    <div>
      <button onClick={() => append({ name: '', value: 0 })}>
        Add Item
      </button>

      {itemsLens.map(fields, (field, itemLens, index) => (
        <div key={field.id}>
          <input {...itemLens.focus('name').interop((ctrl, name) => ctrl.register(name))} />
          <input
            type="number"
            {...itemLens.focus('value').interop((ctrl, name) =>
              ctrl.register(name, { valueAsNumber: true })
            )}
          />
          <button onClick={() => remove(index)}>Remove</button>
          {index > 0 && (
            <button onClick={() => move(index, index - 1)}>Move Up</button>
          )}
        </div>
      ))}
    </div>
  );
}
```

# Performance Optimization

## Caching System

All lenses are cached to prevent component re-renders when using `React.memo`:

```tsx copy
// These will return the same lens instance
assert(lens.focus('firstName') === lens.focus('firstName'));
```

### Memoizing Reflect Functions

When using functions in `reflect`, memoize them for optimal performance:

```tsx copy
// ❌ Creates new function on every render
const reflected = lens.reflect((l) => ({ name: l.focus('firstName') }));

// ✅ Memoized function
const reflected = lens.reflect(useCallback((l) => ({
  name: l.focus('firstName')
}), []));
```

<Admonition type="tip" title="React Compiler">

[React Compiler](https://react.dev/learn/react-compiler) can automatically optimize these functions since they have no side effects.

</Admonition>

---

## Manual Lens Creation

For advanced use cases, you can create lenses manually:

```tsx copy
import { useMemo } from 'react';
import { useForm } from 'react-hook-form';
import { LensCore, LensesStorage } from '@hookform/lenses';

function App() {
  const { control } = useForm<{ firstName: string; lastName: string }>();

  const lens = useMemo(() => {
    const cache = new LensesStorage(control);
    return LensCore.create(control, cache);
  }, [control]);

  return (
    <form>
      <input {...lens.focus('firstName').interop((ctrl, name) => ctrl.register(name))} />
      <input {...lens.focus('lastName').interop((ctrl, name) => ctrl.register(name))} />
    </form>
  );
}
```

---

## TypeScript Support

The library provides excellent TypeScript support with:

- **Path autocompletion**: IntelliSense for available form paths
- **Type inference**: Automatic type inference for focused fields
- **Compile-time safety**: Errors for invalid paths or operations
- **Generic support**: Full support for generic form types

```tsx copy
type FormData = {
  user: {
    profile: {
      name: string;
      contacts: string[];
    };
  };
};

const lens = useLens<FormData>({ control });

// ✅ Type-safe - returns Lens<string>
const nameLens = lens.focus('user.profile.name');

// ✅ Type-safe - returns Lens<string[]>
const contactsLens = lens.focus('user.profile.contacts');

// ❌ TypeScript error - path doesn't exist
const invalidLens = lens.focus('user.invalid.path');
```
