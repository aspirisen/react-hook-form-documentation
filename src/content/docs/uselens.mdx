---
title: useLens
description: Type-safe functional lenses for React Hook Form
sidebar: apiLinks
---

<SelectNav
    options={[
    {
      label: "motivation",
      value: "#motivation",
    },
    {
      label: "focus",
      value: "#focus",
    },
    {
      label: "reflect",
      value: "#reflect",
    },
    {
      label: "map",
      value: "#map",
    },
    {
      label: "interop",
      value: "#interop",
    },
    {
      label: "useFieldArray",
      value: "#usefieldarray",
    },
  ]}
/>

## \</> `useLens:` [`UseLensProps`](/ts#UseLensProps)

React Hook Form Lenses is a powerful TypeScript-first library that brings the elegance of functional lenses to React Hook Form. By providing type-safe manipulation of nested form state, it enables developers to precisely control and transform complex form data with ease.

### Installation

```bash copy
npm install @hookform/lenses
```

### Features

- **Type-Safe Form State**: Focus on specific parts of your form state with full TypeScript support and precise type inference
- **Functional Lenses**: Build complex form state transformations through composable lens operations
- **Deep Structure Support**: Handle deeply nested structures and arrays elegantly with specialized array operations
- **Seamless Integration**: Work smoothly with React Hook Form's Control API and existing functionality
- **Optimized Performance**: Each lens is cached and reused for optimal performance
- **Array Handling**: Specialized support for array fields with type-safe mapping
- **Composable API**: Build complex form state transformations through lens composition

### Motivation

Working with complex, deeply nested forms in React can quickly become challenging. Traditional approaches often lead to:

#### Problems with String-Based Field Names

```tsx copy
// ❌ Fragile string-based approach
const { register } = useForm<ComplexFormData>();

// No type safety, prone to typos
<input {...register('user.profile.personalInfo.firstName')} />
<input {...register('user.profile.personalInfo.lastName')} />
<input {...register('user.profile.contactInfo.email')} />

// Refactoring nightmare when data structure changes
// Hard to catch errors at compile time
```

#### Component Reusability Challenges

```tsx copy
// ❌ Hard to create reusable components
function PersonForm({ basePath }: { basePath: string }) {
  const { register } = useForm();

  return (
    <div>
      {/* String concatenation prone to errors */}
      <input {...register(`${basePath}.firstName`)} />
      <input {...register(`${basePath}.lastName`)} />
      <input {...register(`${basePath}.email`)} />
    </div>
  );
}

// Usage becomes unwieldy
<PersonForm basePath="user.profile.owner" />
<PersonForm basePath="user.profile.emergency_contact" />
```

#### Prop Drilling and Performance Issues

```tsx copy
// ❌ Prop drilling control and register through component tree
function ComplexForm() {
  const { control, register } = useForm<FormData>();

  return (
    <UserSection control={control} register={register} />
  );
}

function UserSection({ control, register }: Props) {
  return (
    <ProfileSection control={control} register={register} />
  );
}

function ProfileSection({ control, register }: Props) {
  // Finally use the props deep in the tree
  return <input {...register('user.profile.name')} />;
}
```

#### How Lenses Solve These Problems

**✅ Type-Safe Field Access**
```tsx copy
const lens = useLens({ control });

// Full TypeScript support with autocompletion
const firstNameLens = lens.focus('user.profile.personalInfo.firstName');
const lastNameLens = lens.focus('user.profile.personalInfo.lastName');

// Compile-time errors for invalid paths
const invalidLens = lens.focus('user.invalid.path'); // ❌ TypeScript error
```

**✅ Truly Reusable Components**
```tsx copy
function PersonForm({ lens }: { lens: Lens<PersonData> }) {
  return (
    <div>
      <input {...lens.focus('firstName').interop((ctrl, name) => ctrl.register(name))} />
      <input {...lens.focus('lastName').interop((ctrl, name) => ctrl.register(name))} />
      <input {...lens.focus('email').interop((ctrl, name) => ctrl.register(name))} />
    </div>
  );
}

// Clean, type-safe usage
<PersonForm lens={lens.focus('user.profile.owner')} />
<PersonForm lens={lens.focus('user.profile.emergencyContact')} />
```

**✅ No Prop Drilling**
```tsx copy
function ComplexForm() {
  const { control } = useForm<FormData>();
  const lens = useLens({ control });

  return <UserSection lens={lens.focus('user')} />;
}

function UserSection({ lens }: { lens: Lens<UserData> }) {
  return <ProfileSection lens={lens.focus('profile')} />;
}

function ProfileSection({ lens }: { lens: Lens<ProfileData> }) {
  // Clean, focused component with no prop drilling
  return <input {...lens.focus('name').interop((ctrl, name) => ctrl.register(name))} />;
}
```

**✅ Structural Flexibility**
```tsx copy
// Transform data structure for different components
const contactForm = lens.reflect(({ user }) => ({
  fullName: user.focus('profile.firstName'),
  phoneNumber: user.focus('profile.phone'),
  emailAddress: user.focus('profile.email'),
}));

// Reuse existing ContactForm component with different data shape
<ContactForm lens={contactForm} />
```

**✅ Performance Optimized**
```tsx copy
// Lenses are cached and prevent unnecessary re-renders
const nameLens = lens.focus('user.name'); // Cached
const sameLens = lens.focus('user.name'); // Returns same instance

assert(nameLens === sameLens); // true
```

This approach leads to:
- **Better Developer Experience**: IntelliSense, autocompletion, and compile-time error checking
- **Improved Maintainability**: Refactoring is safer and easier with type-safe paths
- **Enhanced Reusability**: Components become truly composable and data-structure agnostic
- **Cleaner Architecture**: Clear separation of concerns and reduced coupling
- **Better Performance**: Built-in caching and optimized re-rendering

### Basic Usage

```tsx copy
import { useForm } from 'react-hook-form';
import { useLens } from '@hookform/lenses';

function FormComponent() {
  const { handleSubmit, control } = useForm<{
    firstName: string;
    lastName: string;
    profile: {
      email: string;
      age: number;
    };
  }>();

  const lens = useLens({ control });

  return (
    <form onSubmit={handleSubmit(console.log)}>
      <input {...lens.focus('firstName').interop((ctrl, name) => ctrl.register(name))} />
      <input {...lens.focus('lastName').interop((ctrl, name) => ctrl.register(name))} />
      <input {...lens.focus('profile.email').interop((ctrl, name) => ctrl.register(name))} />
      <input {...lens.focus('profile.age').interop((ctrl, name) => ctrl.register(name, { valueAsNumber: true }))} />
      <input type="submit" />
    </form>
  );
}
```

### Props

#### `control`: <TypeText>Control\<TFieldValues></TypeText>

The control object from React Hook Form's `useForm` hook.

```tsx copy
const { control } = useForm<MyFormData>();
const lens = useLens({ control });
```

You can also pass dependencies to clear lenses cache and re-create all of them:

```tsx copy
const lens = useLens({ control }, [dependencies]);
```

---

## Core Operations

### focus {#focus}

Creates a new lens focused on a specific path. This is the primary method for drilling down into your form data structure.

```tsx copy
// Type-safe path focusing
const profileLens = lens.focus('profile');
const emailLens = lens.focus('profile.email');
const arrayItemLens = lens.focus('users.0.name');
```

**Array focusing:**

```tsx copy
function ContactsList({ lens }: { lens: Lens<Contact[]> }) {
  // Focus on specific array index
  const firstContact = lens.focus('0');
  const secondContactName = lens.focus('1.name');

  return (
    <div>
      <ContactForm lens={firstContact} />
      <input {...secondContactName.interop((ctrl, name) => ctrl.register(name))} />
    </div>
  );
}
```

<Admonition type="important" title="TypeScript Support">

The `focus` method provides full TypeScript support with autocompletion and type checking:

- Autocomplete available field paths
- Type errors for non-existent paths
- Inferred return types based on focused field

</Admonition>

---

### reflect {#reflect}

Transforms the lens structure with type inference. This is useful when you want to create a new lens from an existing one with a different shape to pass to shared components.

#### Object Reflection

```tsx copy
const contactLens = lens.reflect(({ profile }) => ({
  name: profile.focus('firstName'),
  phoneNumber: profile.focus('phone'),
}));

<SharedComponent lens={contactLens} />;

function SharedComponent({ lens }: { lens: Lens<{ name: string; phoneNumber: string }> }) {
  return (
    <div>
      <input {...lens.focus('name').interop((ctrl, name) => ctrl.register(name))} />
      <input {...lens.focus('phoneNumber').interop((ctrl, name) => ctrl.register(name))} />
    </div>
  );
}
```

**Alternative syntax using the lens parameter:**

```tsx copy
const contactLens = lens.reflect((_, l) => ({
  name: l.focus('profile.firstName'),
  phoneNumber: l.focus('profile.phone'),
}));
```

#### Array Reflection

```tsx copy
function ArrayComponent({ lens }: { lens: Lens<{ value: string }[]> }) {
  return <AnotherComponent lens={lens.reflect((_, l) => [{ data: l.focus('value') }])} />;
}

function AnotherComponent({ lens }: { lens: Lens<{ data: string }[]> }) {
  // Handle restructured array
}
```

<Admonition type="note">

For array reflection, you must pass an array with a single item representing the template structure.

</Admonition>

#### Merging Lenses

```tsx copy
function Component({
  lensA,
  lensB
}: {
  lensA: Lens<{ firstName: string }>;
  lensB: Lens<{ lastName: string }>
}) {
  const combined = lensA.reflect((_, l) => ({
    firstName: l.focus('firstName'),
    lastName: lensB.focus('lastName'),
  }));

  return <PersonForm lens={combined} />;
}
```

#### Spread Operator Support

```tsx copy
function Component({ lens }: { lens: Lens<{ firstName: string; lastName: string; age: number }> }) {
  return (
    <PersonForm
      lens={lens.reflect(({ firstName, lastName, ...rest }) => ({
        ...rest,
        name: firstName,
        surname: lastName,
      }))}
    />
  );
}
```

---

### map {#map}

Maps over array fields with `useFieldArray` integration. This method requires the `fields` property from `useFieldArray`.

```tsx copy
import { useFieldArray } from '@hookform/lenses/rhf';

function ContactsList({ lens }: { lens: Lens<Contact[]> }) {
  const { fields, append, remove } = useFieldArray(lens.interop());

  return (
    <div>
      <button onClick={() => append({ name: '', email: '' })}>
        Add Contact
      </button>

      {lens.map(fields, (value, l, index) => (
        <div key={value.id}>
          <button onClick={() => remove(index)}>Remove</button>
          <ContactForm lens={l} />
        </div>
      ))}
    </div>
  );
}

function ContactForm({ lens }: { lens: Lens<{ name: string; email: string }> }) {
  return (
    <div>
      <input {...lens.focus('name').interop((ctrl, name) => ctrl.register(name))} />
      <input {...lens.focus('email').interop((ctrl, name) => ctrl.register(name))} />
    </div>
  );
}
```

**Map callback parameters:**

| Parameter | Type | Description |
|-----------|------|-------------|
| `value` | `T` | The current field value with `id` |
| `lens` | `Lens<T>` | Lens focused on the current array item |
| `index` | `number` | Current array index |
| `array` | `T[]` | The complete array |
| `originLens` | `Lens<T[]>` | The original array lens |

---

### interop {#interop}

The `interop` method provides integration with React Hook Form by exposing the underlying `control` and `name` properties.

#### Basic Usage

```tsx copy
const { control, name } = lens.interop();
return <input {...control.register(name)} />;
```

#### Callback Style

```tsx copy
return (
  <input {...lens.interop((ctrl, name) => ctrl.register(name))} />
);
```

#### With useController

```tsx copy
import { useController } from 'react-hook-form';

function ControlledInput({ lens }: { lens: Lens<string> }) {
  const { field, fieldState } = useController(lens.interop());

  return (
    <div>
      <input {...field} />
      {fieldState.error && <p>{fieldState.error.message}</p>}
    </div>
  );
}
```

#### With Validation Rules

```tsx copy
function ValidatedInput({ lens }: { lens: Lens<string> }) {
  return (
    <input
      {...lens.interop((ctrl, name) =>
        ctrl.register(name, {
          required: 'This field is required',
          minLength: { value: 3, message: 'Min length is 3' }
        })
      )}
    />
  );
}
```

---

### useFieldArray {#usefieldarray}

Import the enhanced `useFieldArray` from `@hookform/lenses/rhf` for seamless array handling with lenses.

```tsx copy
import { useFieldArray } from '@hookform/lenses/rhf';

function DynamicForm({ lens }: { lens: Lens<{ items: { name: string; value: number }[] }> }) {
  const itemsLens = lens.focus('items');
  const { fields, append, remove, move } = useFieldArray(itemsLens.interop());

  return (
    <div>
      <button onClick={() => append({ name: '', value: 0 })}>
        Add Item
      </button>

      {itemsLens.map(fields, (field, itemLens, index) => (
        <div key={field.id}>
          <input {...itemLens.focus('name').interop((ctrl, name) => ctrl.register(name))} />
          <input
            type="number"
            {...itemLens.focus('value').interop((ctrl, name) =>
              ctrl.register(name, { valueAsNumber: true })
            )}
          />
          <button onClick={() => remove(index)}>Remove</button>
          {index > 0 && (
            <button onClick={() => move(index, index - 1)}>Move Up</button>
          )}
        </div>
      ))}
    </div>
  );
}
```

---

## Advanced Examples

### Complex Nested Forms

```tsx copy
interface MovieCollection {
  studio: {
    name: string;
    location: string;
    owner: {
      personName: string;
      yearOfBirth: number;
    };
  };
  movies: {
    title: string;
    summary: string;
    actors: {
      name: string;
      birthYear: number;
    }[];
  }[];
}

function ComplexForm() {
  const { handleSubmit, control } = useForm<MovieCollection>();
  const lens = useLens({ control });

  return (
    <form onSubmit={handleSubmit(console.log)}>
      <StringInput lens={lens.focus('studio.name')} label="Studio Name" />
      <StringInput lens={lens.focus('studio.location')} label="Studio Location" />

      <PersonForm
        lens={lens.focus('studio.owner').reflect(({ personName, yearOfBirth }) => ({
          name: personName,
          birthYear: yearOfBirth
        }))}
      />

      <MoviesForm lens={lens.focus('movies')} />
      <button type="submit">Submit</button>
    </form>
  );
}
```

### Reusable Components with Lenses

```tsx copy
// Reusable input component
function StringInput({ lens, label, ...rules }: {
  lens: Lens<string>;
  label: string;
} & RegisterOptions) {
  return (
    <label>
      {label}
      <input {...lens.interop((ctrl, name) => ctrl.register(name, rules))} />
    </label>
  );
}

// Reusable person form
function PersonForm({ lens }: { lens: Lens<{ name: string; birthYear: number }> }) {
  return (
    <div>
      <StringInput
        lens={lens.focus('name')}
        label="Name"
        required="Name is required"
      />
      <NumberInput
        lens={lens.focus('birthYear')}
        label="Birth Year"
        min={{ value: 1900, message: "Must be after 1900" }}
      />
    </div>
  );
}
```

---

## Performance Optimization

### Caching System

All lenses are cached to prevent component re-renders when using `React.memo`:

```tsx copy
// These will return the same lens instance
assert(lens.focus('firstName') === lens.focus('firstName'));
```

### Memoizing Reflect Functions

When using functions in `reflect`, memoize them for optimal performance:

```tsx copy
// ❌ Creates new function on every render
const reflected = lens.reflect((l) => ({ name: l.focus('firstName') }));

// ✅ Memoized function
const reflected = lens.reflect(useCallback((l) => ({
  name: l.focus('firstName')
}), []));
```

<Admonition type="tip" title="React Compiler">

[React Compiler](https://react.dev/learn/react-compiler) can automatically optimize these functions since they have no side effects.

</Admonition>

---

## Manual Lens Creation

For advanced use cases, you can create lenses manually:

```tsx copy
import { useMemo } from 'react';
import { useForm } from 'react-hook-form';
import { LensCore, LensesStorage } from '@hookform/lenses';

function App() {
  const { control } = useForm<{ firstName: string; lastName: string }>();

  const lens = useMemo(() => {
    const cache = new LensesStorage(control);
    return LensCore.create(control, cache);
  }, [control]);

  return (
    <form>
      <input {...lens.focus('firstName').interop((ctrl, name) => ctrl.register(name))} />
      <input {...lens.focus('lastName').interop((ctrl, name) => ctrl.register(name))} />
    </form>
  );
}
```

---

## TypeScript Support

The library provides excellent TypeScript support with:

- **Path autocompletion**: IntelliSense for available form paths
- **Type inference**: Automatic type inference for focused fields
- **Compile-time safety**: Errors for invalid paths or operations
- **Generic support**: Full support for generic form types

```tsx copy
type FormData = {
  user: {
    profile: {
      name: string;
      contacts: string[];
    };
  };
};

const lens = useLens<FormData>({ control });

// ✅ Type-safe - returns Lens<string>
const nameLens = lens.focus('user.profile.name');

// ✅ Type-safe - returns Lens<string[]>
const contactsLens = lens.focus('user.profile.contacts');

// ❌ TypeScript error - path doesn't exist
const invalidLens = lens.focus('user.invalid.path');
```

---

## Error Handling

Lenses work seamlessly with React Hook Form's error handling:

```tsx copy
function ValidatedForm() {
  const { handleSubmit, control, formState: { errors } } = useForm<{
    email: string;
    password: string;
  }>();

  const lens = useLens({ control });

  return (
    <form onSubmit={handleSubmit(console.log)}>
      <div>
        <input
          {...lens.focus('email').interop((ctrl, name) =>
            ctrl.register(name, {
              required: 'Email is required',
              pattern: {
                value: /^\S+@\S+$/i,
                message: 'Invalid email format'
              }
            })
          )}
        />
        {errors.email && <span>{errors.email.message}</span>}
      </div>

      <div>
        <input
          type="password"
          {...lens.focus('password').interop((ctrl, name) =>
            ctrl.register(name, {
              required: 'Password is required',
              minLength: {
                value: 8,
                message: 'Password must be at least 8 characters'
              }
            })
          )}
        />
        {errors.password && <span>{errors.password.message}</span>}
      </div>

      <button type="submit">Submit</button>
    </form>
  );
}
```

---

## Migration Guide

### From Manual Field Management

**Before (manual):**
```tsx copy
function Form() {
  const { register, control } = useForm<{ user: { name: string; email: string } }>();

  return (
    <form>
      <input {...register('user.name')} />
      <input {...register('user.email')} />
    </form>
  );
}
```

**After (with lenses):**
```tsx copy
function Form() {
  const { control } = useForm<{ user: { name: string; email: string } }>();
  const lens = useLens({ control });

  return (
    <form>
      <input {...lens.focus('user.name').interop((ctrl, name) => ctrl.register(name))} />
      <input {...lens.focus('user.email').interop((ctrl, name) => ctrl.register(name))} />
    </form>
  );
}
```

### Benefits of Migration

- **Type Safety**: Compile-time checking of field paths
- **Composability**: Reusable form components with different data shapes
- **Maintainability**: Clear lens-based architecture for complex forms
- **Performance**: Built-in caching and optimization

---

## API Reference

| Method | Description | Returns |
|--------|-------------|---------|
| [`useLens`](#uselens) | Creates a lens from React Hook Form control | `Lens<T>` |
| [`focus`](#focus) | Focuses on a specific field path | `Lens<PathValue>` |
| [`reflect`](#reflect) | Transforms lens structure | `Lens<NewStructure>` |
| [`map`](#map) | Maps over array with useFieldArray fields | `R[]` |
| [`interop`](#interop) | Provides React Hook Form integration | `{ control, name }` |

---

## Best Practices

1. **Use TypeScript**: Leverage full type safety for better development experience
2. **Memoize functions**: Use `useCallback` for functions passed to `reflect`
3. **Component composition**: Create reusable components that accept lens props
4. **Error handling**: Integrate with React Hook Form's built-in validation
5. **Performance**: Utilize the caching system by avoiding inline functions

---

## Troubleshooting

### Common Issues

**Lens cache not working with reflect:**
```tsx copy
// ❌ Creates new function each render
lens.reflect((l) => ({ name: l.focus('firstName') }))

// ✅ Memoized function
lens.reflect(useCallback((l) => ({ name: l.focus('firstName') }), []))
```

**Type errors with complex paths:**
```tsx copy
// Ensure your form type matches your lens usage
type FormData = {
  user: {
    profile: {
      name: string;
    };
  };
};

// This path must exist in FormData
lens.focus('user.profile.name') // ✅
lens.focus('user.invalid') // ❌ TypeScript error
```

**Array operations not working:**
```tsx copy
// Make sure to use the enhanced useFieldArray
import { useFieldArray } from '@hookform/lenses/rhf'; // ✅
import { useFieldArray } from 'react-hook-form'; // ❌ Won't work with lenses
```
