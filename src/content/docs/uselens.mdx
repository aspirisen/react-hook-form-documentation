---
title: useLens
description: Type-safe functional lenses for React Hook Form
sidebar: apiLinks
---

## \</> `useLens`

React Hook Form Lenses is a powerful TypeScript-first library that brings the elegance of functional lenses to React Hook Form. By providing type-safe manipulation of nested form state, it enables developers to precisely control and transform complex form data with ease.

### Installation

```bash copy
npm install @hookform/lenses
```

### Features

- **Type-Safe Form State**: Focus on specific parts of your form state with full TypeScript support and precise type inference
- **Functional Lenses**: Build complex form state transformations through composable lens operations
- **Deep Structure Support**: Handle deeply nested structures and arrays elegantly with specialized array operations
- **Seamless Integration**: Work smoothly with React Hook Form's Control API and existing functionality
- **Optimized Performance**: Each lens is cached and reused for optimal performance
- **Array Handling**: Specialized support for array fields with type-safe mapping
- **Composable API**: Build complex form state transformations through lens composition

---

## API Reference

### Core Types

#### `Lens<T>`

The main lens type that provides operations based on the field type:

```ts
type LensWithArray = Lens<string[]>;
type LensWithObject = Lens<{ name: string; age: number }>;
type LensWithPrimitive = Lens<string>;
```

### Hooks

#### `useLens`

Creates a new lens instance:

```tsx
const lens = useLens({
  control: form.control, // React Hook Form control
});
```

You can also pass dependencies to clear lenses cache and re-create all of them:

```tsx
const lens = useLens(
  {
    control: form.control, // React Hook Form control
  },
  [dependencies], // optional dependency array if you need to clear caches
);
```

### Lens Operations

| Method | Description | Returns |
|--------|-------------|---------|
| [`focus`](#focus) | Focuses on a specific field path | `Lens<PathValue>` |
| [`reflect`](#reflect) | Transforms lens structure | `Lens<NewStructure>` |
| [`map`](#map) | Maps over array with useFieldArray fields | `R[]` |
| [`interop`](#interop) | Provides React Hook Form integration | `{ control, name }` |

---


## Basic Usage

```tsx copy sandbox="https://codesandbox.io/p/sandbox/keen-herschel-y5h2ft"
import { useForm } from 'react-hook-form';
import { Lens, useLens } from '@hookform/lenses';
import { useFieldArray } from '@hookform/lenses/rhf';

function FormComponent() {
  const { handleSubmit, control } = useForm<{
    firstName: string;
    lastName: string;
    children: {
      name: string;
      surname: string;
    }[];
  }>({});

  const lens = useLens({ control });

  return (
    <form onSubmit={handleSubmit(console.log)}>
      <PersonForm
        lens={lens.reflect(({ firstName, lastName }) => ({
          name: firstName,
          surname: lastName,
        }))}
      />
      <ChildForm lens={lens.focus('children')} />
      <input type="submit" />
    </form>
  );
}

function ChildForm({ lens }: { lens: Lens<{ name: string; surname: string }[]> }) {
  const { fields, append } = useFieldArray(lens.interop());

  return (
    <>
      <button type="button" onClick={() => append({ name: '', surname: '' })}>
        Add child
      </button>
      {lens.map(fields, (value, l) => (
        <PersonForm key={value.id} lens={l} />
      ))}
    </>
  );
}

// PersonForm is used twice with different sources
function PersonForm({ lens }: { lens: Lens<{ name: string; surname: string }> }) {
  return (
    <div>
      <StringInput lens={lens.focus('name')} />
      <StringInput lens={lens.focus('surname')} />
    </div>
  );
}

function StringInput({ lens }: { lens: Lens<string> }) {
  return <input {...lens.interop((ctrl, name) => ctrl.register(name))} />;
}
```

# Motivation

Working with complex, deeply nested forms in React can quickly become challenging. Traditional approaches often lead to:

#### Problems with String-Based Field Names

```tsx
// ❌ Fragile string-based approach
const { register } = useForm<ComplexFormData>();

// No type safety, prone to typos
<input {...register('user.profile.personalInfo.firstName')} />
<input {...register('user.profile.personalInfo.lastName')} />
<input {...register('user.profile.contactInfo.email')} />

// Refactoring nightmare when data structure changes
// Hard to catch errors at compile time
```

#### Component Reusability Challenges

```tsx
// ❌ Hard to create reusable components
function PersonForm({ basePath }: { basePath: string }) {
  const { register } = useForm();

  return (
    <div>
      {/* String concatenation prone to errors */}
      <input {...register(`${basePath}.firstName`)} />
      <input {...register(`${basePath}.lastName`)} />
      <input {...register(`${basePath}.email`)} />
    </div>
  );
}

// Usage becomes unwieldy
<PersonForm basePath="user.profile.owner" />
<PersonForm basePath="user.profile.emergency_contact" />
```

#### Prop Drilling and Type Safety difficulties

```tsx
// ❌ Prop drilling control and register through component tree
function ComplexForm() {
  const { control, register } = useForm<FormData>();

  return (
    <UserSection control={control} register={register} />
  );
}

function UserSection({ control, register }: Props) {
  return (
    <ProfileSection control={control} register={register} />
  );
}

function ProfileSection({ control, register }: Props) {
  // Finally use the props deep in the tree
  return <input {...register('user.profile.name')} />;
}
```


# Props

#### `control`: <TypeText>Control\<TFieldValues></TypeText>

The control object from React Hook Form's `useForm` hook.

```tsx copy
const { control } = useForm<MyFormData>();
const lens = useLens({ control });
```

You can also pass dependencies to clear lenses cache and re-create all of them:

```tsx copy
const lens = useLens({ control }, [dependencies]);
```

---

# Core Operations

### focus {#focus}

Creates a new lens focused on a specific path. This is the primary method for drilling down into your form data structure.

```tsx copy
// Type-safe path focusing
const profileLens = lens.focus('profile');
const emailLens = lens.focus('profile.email');
const arrayItemLens = lens.focus('users.0.name');
```

**Array focusing:**

```tsx copy
function ContactsList({ lens }: { lens: Lens<Contact[]> }) {
  // Focus on specific array index
  const firstContact = lens.focus('0');
  const secondContactName = lens.focus('1.name');

  return (
    <div>
      <ContactForm lens={firstContact} />
      <input {...secondContactName.interop((ctrl, name) => ctrl.register(name))} />
    </div>
  );
}
```

<Admonition type="important" title="TypeScript Support">

The `focus` method provides full TypeScript support with autocompletion and type checking:

- Autocomplete available field paths
- Type errors for non-existent paths
- Inferred return types based on focused field

</Admonition>

---

### reflect {#reflect}

Transforms the lens structure with type inference. It is useful when you want to create a new lens from an existing one with a different shape to pass it to a shared component.

The first argument is a Proxy with dictionary of lenses. Pay attention that Lens instantiation happens only on property access. The second argument is the original lens.

#### Object Reflection

```tsx copy
const contactLens = lens.reflect(({ profile }) => ({
  name: profile.focus('contact.firstName'),
  phoneNumber: profile.focus('contact.phone'),
}));

<SharedComponent lens={contactLens} />;

function SharedComponent({ lens }: { lens: Lens<{ name: string; phoneNumber: string }> }) {
  return (
    <div>
      <input {...lens.focus('name').interop((ctrl, name) => ctrl.register(name))} />
      <input {...lens.focus('phoneNumber').interop((ctrl, name) => ctrl.register(name))} />
    </div>
  );
}
```

**Alternative syntax using the lens parameter:**

You can also use the second parameter (the original lens) directly:

```tsx
const contactLens = lens.reflect((_, l) => ({
  name: l.focus('profile.contact.firstName'),
  phoneNumber: l.focus('profile.contact.phone'),
}));

<SharedComponent lens={contactLens} />;

function SharedComponent({ lens }: { lens: Lens<{ name: string; phoneNumber: string }> }) {
  // ...
}
```

#### Array Reflection

You can restructure array lenses:

```tsx
function ArrayComponent({ lens }: { lens: Lens<{ value: string }[]> }) {
  return <AnotherComponent lens={lens.reflect((_, l) => [{ data: l.focus('value') }])} />;
}

function AnotherComponent({ lens }: { lens: Lens<{ data: string }[]> }) {
  // ...
}
```

<Admonition type="important">

Pay attention that in case of array reflecting you have to pass an array with single item.

</Admonition>

#### Merging Lenses

You can use `reflect` to merge two lenses into one:

```tsx
function Component({
  lensA,
  lensB
}: {
  lensA: Lens<{ firstName: string }>;
  lensB: Lens<{ lastName: string }>
}) {
  const combined = lensA.reflect((_, l) => ({
    firstName: l.focus('firstName'),
    lastName: lensB.focus('lastName'),
  }));

  return <PersonForm lens={combined} />;
}
```

Keep in mind that in such case the passed to `reflect` function is no longer pure.

#### Spread Operator Support

You can use spread in reflect if you want to leave other properties as is. In runtime the first argument is just a proxy that calls `focus` on the original lens. The is useful for proper typing if you need to change the prop names only for several fields, and leave the rest as is:

```tsx
function Component({ lens }: { lens: Lens<{ firstName: string; lastName: string; age: number }> }) {
  return (
    <PersonForm
      lens={lens.reflect(({ firstName, lastName, ...rest }) => ({
        ...rest,
        name: firstName,
        surname: lastName,
      }))}
    />
  );
}
```

---

### map {#map}

Maps over array fields with `useFieldArray` integration. This method requires the `fields` property from `useFieldArray`.

```tsx copy
import { useFieldArray } from '@hookform/lenses/rhf';

function ContactsList({ lens }: { lens: Lens<Contact[]> }) {
  const { fields, append, remove } = useFieldArray(lens.interop());

  return (
    <div>
      <button onClick={() => append({ name: '', email: '' })}>
        Add Contact
      </button>

      {lens.map(fields, (value, l, index) => (
        <div key={value.id}>
          <button onClick={() => remove(index)}>Remove</button>
          <ContactForm lens={l} />
        </div>
      ))}
    </div>
  );
}

function ContactForm({ lens }: { lens: Lens<{ name: string; email: string }> }) {
  return (
    <div>
      <input {...lens.focus('name').interop((ctrl, name) => ctrl.register(name))} />
      <input {...lens.focus('email').interop((ctrl, name) => ctrl.register(name))} />
    </div>
  );
}
```

**Map callback parameters:**

| Parameter | Type | Description |
|-----------|------|-------------|
| `value` | `T` | The current field value with `id` |
| `lens` | `Lens<T>` | Lens focused on the current array item |
| `index` | `number` | Current array index |
| `array` | `T[]` | The complete array |
| `originLens` | `Lens<T[]>` | The original array lens |

---

### interop {#interop}

The `interop` method provides integration with react-hook-form by exposing the underlying `control` and `name` properties. This allows you to connect your lens to react-hook-form's control API.

#### First Variant: Object Return

The first variant involves calling `interop()` without arguments, which returns an object containing the `control` and `name` properties for react-hook-form:

```tsx
const { control, name } = lens.interop();

return <input {...control.register(name)} />;
```

#### Second Variant: Callback Function

The second variant is passing a callback function to `interop` which receives the `control` and `name` properties as arguments. This allows you to work with these properties directly within the callback scope:

```tsx
return (
  <form onSubmit={handleSubmit(console.log)}>
    <input {...lens.interop((ctrl, name) => ctrl.register(name))} />
    <input type="submit" />
  </form>
);
```

#### Integration with useController

The `interop` method's return value can be passed directly to the `useController` hook from react-hook-form, providing seamless integration:

```tsx
import { useController } from 'react-hook-form';

function ControlledInput({ lens }: { lens: Lens<string> }) {
  const { field, fieldState } = useController(lens.interop());

  return (
    <div>
      <input {...field} />
      {fieldState.error && <p>{fieldState.error.message}</p>}
    </div>
  );
}
```

---

### useFieldArray {#usefieldarray}

Import the enhanced `useFieldArray` from `@hookform/lenses/rhf` for seamless array handling with lenses.

```tsx copy
import { useFieldArray } from '@hookform/lenses/rhf';

function DynamicForm({ lens }: { lens: Lens<{ items: { name: string; value: number }[] }> }) {
  const itemsLens = lens.focus('items');
  const { fields, append, remove, move } = useFieldArray(itemsLens.interop());

  return (
    <div>
      <button onClick={() => append({ name: '', value: 0 })}>
        Add Item
      </button>

      {itemsLens.map(fields, (field, itemLens, index) => (
        <div key={field.id}>
          <input {...itemLens.focus('name').interop((ctrl, name) => ctrl.register(name))} />
          <input
            type="number"
            {...itemLens.focus('value').interop((ctrl, name) =>
              ctrl.register(name, { valueAsNumber: true })
            )}
          />
          <button onClick={() => remove(index)}>Remove</button>
          {index > 0 && (
            <button onClick={() => move(index, index - 1)}>Move Up</button>
          )}
        </div>
      ))}
    </div>
  );
}
```

# Performance Optimization

## Caching System

All the lenses are cached to prevent component re-renders when utilizing `React.memo`. It means that focusing the same path multiple times will not create new lens instance:

```tsx
assert(lens.focus('firstName') === lens.focus('firstName'));
```

However, there are some difficulties when you use functions, i.e. in `reflect`:

```tsx
lens.reflect((l) => l.focus('firstName'))
```

To make the caching work, you need to memoize the function you pass:

```tsx
lens.reflect(useCallback((l) => l.focus('firstName'), []));
```
<Admonition type="tip" title="React Compiler">

Here is the case where [React Compiler](https://react.dev/learn/react-compiler) can be extremely helpful. Because the function you pass to `reflect` has no side effects, react compiler will hoist it to module scope and thus lens cache will work as expected.

</Admonition>

---

## Advanced Usage

### Manual Lens Creation

You can create lenses manually without `useLens` hook by utilizing the `LensCore` class:

```tsx
import { useMemo } from 'react';
import { useForm } from 'react-hook-form';
import { LensCore, LensesStorage } from '@hookform/lenses';

function App() {
  const { control } = useForm<{ firstName: string; lastName: string }>();

  const lens = useMemo(() => {
    const cache = new LensesStorage(control);
    return LensCore.create(control, cache);
  }, [control]);

  lens.focus('firstName');
  lens.focus('lastName');
}
```
